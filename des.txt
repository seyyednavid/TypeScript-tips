// convert typescript to js => es5
tsc index.ts 


// creating tsconfig.json -- turn ES5(var) to Es6(let, const)
tsc --init


// let sales = 123_456_789 annotate
let sales: number = 123_456_789


// type any 
let level;


function render(document: any) {
  console.log(document);
}


//Array of numbers
let numbers: number[] = [1, 2, 3]


//Array of any => like javascript
let numbers = []


//topple
let user: [number, string] = [1, "Navid"]


//Enum
// const small = 's';
// const medium = 'm';
// const large = 'l';
(const) enum Size {Small = 's', Medium = 'm', Large= 'l'};
let mySize: Size = Size.Medium
console.log(mySize);


//function
function calculateTax(income: number , taxYear: number) : number {
  if (taxYear < 50_000) {
    return income * 1.2;
  } 
  return income * 1.3
}
function calculateTax(income: number , taxYear = 2022) : number {
  if (taxYear < 50_000) {
    return income * 1.2;
  } 
  return income * 1.3
}
calculateTax(10000, 100);
calculateTax(10000);



//Object
let employee: {
  id: number,
  name: string,
  retire: (date : Date) => void
} = {
  id: 1,
  name: 'Ali',
  retire: (date: Date) => {
    console.log(date);
  }
}
employee.name = "David"

// read only property
let employee1: {
  readonly id: number;
  name: string;
} = {
  id: 1,
  name: "Ali",
};
employee1.id = 2; //XXXX

// Define type employee
type Employee = {
  readonly id: number;
  name: string;
  retire: (date: Date) => void;
};


let employee: Employee = {
  id: 1,
  name: '',
  retire: (date: Date) => {
    console.log(date);
  }
}



// Union types
function kgToLbs(weight: number | string): number {
  if (typeof weight === "number") 
   return weight * 2.2;
  else
   return parseInt(weight) * 2.2;
}


// Intersection types
let weight: number & string;

type Dragable = {
  drag: () => void
}

type resizeable = {
  resize: () => void;
}

type UIWidget = Dragable & resizeable;

let textBox: UIWidget = {
  drag: () => {},
  resize: () => {}
}


// Literal types
type Quantity = 50 | 100;
let quantity: Quantity = 50;

type Metric = 'cm'|'inch';
let metric: Metric = 'cm'


// Nullable types
function greet(name: string | null | undefined) {
  if(name)
    console.log(name)
  else 
    console.log('invalid argument')
}
greet(undefined)


// Optional chain
// Optional chain
type Customer = {
  birthDate?: Date; // optional property
};
function getCustomer(id: number): Customer | null | undefined {
  return id === 0 ? null : { birthDate: new Date() };
}
// let customerOne = getCustomer(0);
// if (customerOne !== null && customerOne !== undefined)
//   console.log(customerOne.birthDate);

// Easy solution - chaining operator
let customerOne = getCustomer(0);
console.log(customerOne?.birthDate?.getFullYear);
//example ==> customer?.[0]


// Example
// let log: any = (message: string) => console.log(message);
let log: any = null
log?.('a'); //when will be executed that log is a function


// nullish operator
let speed: number | null = 0
// let ride = {
//   speed: speed !== null ? speed : 30
// }
//means if the value is null and undefined equal 30
let ride = {
  speed: speed ?? 30
}
console.log(ride.speed);

// type assertion
// let phone = document.getElementById("phone") as HTMLInputElement;
let phone = <HTMLInputElement> document.getElementById("phone");
phone.value 


// unknown
function render (document : unknown) {
  // typeof for primitive
  if (typeof document === "string") {
  } // instanceof for reference
  else if (document instanceof Object) {
  }
  
}


// never 
function processEvent(): never{
  while(true){
    console.log("hi");
  }
}
processEvent();
// below cod won't be executed because all the time are working
console.log("hey");

------------------------------------------------------------

//Object behavior
object => Data(state, properties) + behavior(operation, method)


class Account {
  id: number;
  name: string;
  balance: number;
  constructor(id: number, name: string, balance: number){
    this.id = id;
    this.name = name;
    this.balance = balance;
  }
  deposit(amount: number): void{
    if(amount <= 0) {
      throw new Error("invalid amount")
    } 
    this.balance +=  amount;
  }
}
let account = new Account(1, 'David', 0)
account.deposit(100);
console.log(typeof account);
console.log(account instanceof Account)




// Access Modifiers
class Account {
  readonly id: number; // No changes
  name: string;
  nickname ?: string; //Optional
  private _balance: number;  // Private

  constructor(id: number, name: string, balance: number){
    this.id = id;
    this.name = name;
    this._balance = balance;
  }
  deposit(amount: number): void{
    if(amount <= 0) {
      throw new Error("invalid amount")
    } 
    this._balance +=  amount;
  }
  getBalance(): number {
    return this._balance
  }
  private _calculateTax(_balance: number): number{ // Private
    return (_balance * 20) / 100;
  }
  
}
let account = new Account(1, 'David', 0)
console.log(account.getBalance());
//Access modifier
// public - private(only accessable within class) - protected


// Parameter Property
class Account {
  
  constructor(
    public readonly id: number,
    public name: string,
    private _balance: number,
    public nickname ?: string
  ) {}

  deposit(amount: number): void {
    if (amount <= 0) {
      throw new Error("invalid amount");
    }
    this._balance += amount;
  }

  getBalance(): number {
    return this._balance;
  }

}




// The second way for work with private properties and methods
// Getter and Setter

class Account {
  constructor(
    public readonly id: number,
    public name: string,
    private _balance: number,
    public nickname?: string
  ) {}

  deposit(amount: number): void {
    if (amount <= 0) {
      throw new Error("invalid amount");
    }
    this._balance += amount;
  }

  get balance(): number {
    // with adding get we can read balance property indirectly console.log(account.balance)
    return this._balance;
  }
  set balance(value: number) {
    // with adding set we can set balance property's value indirectly => account.balance = 1
    if (value < 0) throw new Error("Invalid value");
    this._balance = value;
  }

  private calculateTax() {}
}

let account = new Account(1, "David", 0);
console.log(account.balance); // get
account.balance = 1; //set

// in total we do not need setter , because there is no reason to user be able to change the balance value



// Dynamic property

//Sometimes we need to have dynamic objects, in default
//typescript do not allow to create dynamic objects
// we should use index signature property
class SeatAssignment {
  [seatNumber: string]: string;
}

let seats = new SeatAssignment()
seats.A1 = 'mohammad';
// seat['A1'] = "mohammad"
seats.A2 = "Amir";




// static members
// class Ride{
//   //passenger
//   //pickupLocation
//   //DropOffLocation
//    activeRides: number = 0;

//   start(){
//     this.activeRides++;
//   }

//   stop(){
//     this.activeRides--;
//   }

// }

// let ride1= new Ride();
// ride1.start()

// let ride2= new Ride();
// ride2.start()

// console.log(ride1.activeRides); // 1
// console.log(ride2.activeRides);  // 1
// we need activeRides consider public (belong to class) not for each object separately


// static members
class Ride {
  //passenger
  //pickupLocation
  //DropOffLocation
  private static _activeRides: number = 0;

  start() {
    Ride._activeRides++;
  }

  stop() {
    Ride._activeRides--;
  }
// for static type before get we should add static
  static get activeRides(): number {
    return Ride._activeRides;
  }
}

let ride1= new Ride();
ride1.start()

let ride2= new Ride();
ride2.start()

console.log(Ride.activeRides);






//Inheritance
class Person {
  constructor(
    public firstName: string, 
    public lastName: string
    ) {}
  walk() {
    console.log("walking");
  }
  get fullName(): String {
    return this.firstName + " " + this.lastName;
  }
}

class Student extends Person {
  constructor(
    public studentId: number, 
    firstName: string, 
    lastName: string) {
    super(firstName, lastName);
  }

  takeTest(){
    console.log("Taking a test");
  }
}
let student = new Student(1,"David", "Hejazi")




// Method overriding
class Person {
  constructor(
    public firstName: string, 
    public lastName: string
    ) {}
  walk() {
    console.log("walking");
  }
  get fullName(): String {
    return this.firstName + " " + this.lastName;
  }
}

class Student extends Person {
  constructor(
    public studentId: number, 
    firstName: string, 
    lastName: string) {
    super(firstName, lastName);
  }

  takeTest(){
    console.log("Taking a test");
  }
}

class Teacher extends Person {
   override get fullName(): string {
    // return 'professor' + this.firstName + " " + this.lastName
     return 'professor ' + super.fullName;
   }
}

const teacher = new Teacher('Ali', "ostad")
console.log(teacher.fullName);





// polymorphic =>  we can use this feature when we use override otherwise this feature won't be used.
class Person {
  constructor(public firstName: string, public lastName: string) {}
  walk() {
    console.log("walking");
  }
  get fullName(): String {
    return this.firstName + " " + this.lastName;
  }
}
class Student extends Person {
  constructor(public studentId: number, firstName: string, lastName: string) {
    super(firstName, lastName);
  }
  takeTest() {
    console.log("Taking a test");
  }
}
class Teacher extends Person {
  override get fullName(): string {
    // return 'professor' + this.firstName + " " + this.lastName
    return "professor " + super.fullName;
  }
}

class Principal extends Person {
  override get fullName(): string {
    return "principal " + super.fullName;
  }
}

function printNames(people: Person[]) {
  for (let person of people) {
    console.log(person.fullName);
  }
}

printNames([
  new Student(1, "Navid", "hejazi"),
  new Teacher("mohammad", "ali"),
  new Principal("maziar", "yousefi"),
]);



// access modifier protected
// protected members can be inherited but private members can not be protected
class Person {
  constructor(
    public firstName: string, 
    public lastName: string
    ) {}

  protected walk() {
    console.log("walking");
  }
  get fullName(): String {
    return this.firstName + " " + this.lastName;
  }
}

class Student extends Person {
  constructor(public studentId: number, firstName: string, lastName: string) {
    super(firstName, lastName);
  }

  takeTest() {
    this.
    console.log("Taking a test");
  }
}





// abstract class - for we are not allowed to create object from a class
// we can have method abstract(there is no code in method body) only in class abstract
abstract class Shape {
  constructor(public color: string) {}

  // render() {}
  abstract render(): void
}

class Circle extends Shape{
  constructor(
    public radious: number,
    color: string
  ){
    super(color)
  }

  override render(): void{
    console.log("rendering a circle");
  }
}
let shape = new Shape("red")
shape.render()






// Interface ==> determine the shape of object

// abstract class Calender {
//   constructor(public name: string) {}

//   abstract addEvent(): void;
//   abstract removeEvent(): void;
// }
interface Calender {
 name: string;
 addEvent(): void;
 removeEvent(): void;
}

interface CloudCalender extends Calender {
  sync(): void;
}
// when we use tsc we can not anything in index.js
// because js does not have interface concept

// if we have specific logic in parent and we wanna use them in children
// it is better to use the first method.
// Otherwise the second method because code be less and more tidy


// with implements we can use interfaces
class GoogleCalender implements Calender {
  constructor(public name:string){}
  addEvent(): void {}
  removeEvent(): void {}
}
-------------------------------------------------------------